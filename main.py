# -*- coding: utf-8 -*-
"""FuelGrowth.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ym3YQFUsIdhiujijZ7ZZx97JCQRQreBO
"""

!pip install pytube opencv-python-headless deepface scikit-learn pandas tqdm ffmpeg-python

import pandas as pd

sheet_url = "https://docs.google.com/spreadsheets/d/1Bj4-sd6362GWrFZOPcND3fFo0oroO1pfhkpMJh8iIE4/edit?usp=sharing"
sheet_url = sheet_url.replace('/edit?usp=sharing', '/export?format=csv')
df = pd.read_csv(sheet_url)

print(df.head())

df = df.dropna(subset=['Video URL', 'Performance'])
df['Performance'] = pd.to_numeric(df['Performance'], errors='coerce')

import requests

def download_video(link, output_path):
    try:
        response = requests.get(link, stream=True, timeout=10)
        if response.status_code == 200:
            with open(output_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=1024):
                    f.write(chunk)
            print(f"Downloaded: {output_path}")
        else:
            print(f"Failed to download {link}: {response.status_code}")
    except Exception as e:
        print(f"Error downloading {link}: {e}")

for i, link in enumerate(df['Video URL']):
    output_file = f'videos/video_{i}.mp4'
    download_video(link, output_file)

!pip install retina-face

!pip install --upgrade tensorflow

from retinaface import RetinaFace
import cv2
import os
from tqdm import tqdm

def extract_faces_retina(video_path, output_dir="faces"):
    """
    Extracts faces from a video using RetinaFace and saves them as images.

    Parameters:
    - video_path: Path to the input video file.
    - output_dir: Directory to save the extracted faces.
    """
    os.makedirs(output_dir, exist_ok=True)
    cap = cv2.VideoCapture(video_path)
    frame_count = 0
    face_count = 0

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        faces = RetinaFace.detect_faces(frame)

        for face_key in faces.keys():
            face_data = faces[face_key]
            x, y, x2, y2 = face_data['facial_area']
            x, y, x2, y2 = max(0, x), max(0, y), x2, y2
            face = frame[y:y2, x:x2]

            if face.shape[0] > 50 and face.shape[1] > 50:
                face_path = os.path.join(output_dir, f"{os.path.basename(video_path)}_frame{frame_count}_face{face_count}.jpg")
                cv2.imwrite(face_path, face)
                face_count += 1

        frame_count += 1

    cap.release()
    print(f"Faces from {video_path} saved to {output_dir}.")

def process_all_videos(video_folder="videos", output_folder="faces"):
    """
    Process all video files in a directory to extract faces.

    Parameters:
    - video_folder: Path to the folder containing input videos.
    - output_folder: Path to the folder where faces will be saved.
    """
    video_paths = [os.path.join(video_folder, f) for f in os.listdir(video_folder) if f.endswith(('.mp4', '.avi', '.mkv'))]
    for video_path in tqdm(video_paths, desc="Processing Videos"):
        video_output_dir = os.path.join(output_folder, os.path.basename(video_path).split('.')[0])
        extract_faces_retina(video_path, video_output_dir)

process_all_videos(video_folder="videos", output_folder="faces")

!pip install deepface

import os
import shutil
from sklearn.metrics.pairwise import cosine_similarity
from deepface import DeepFace

def get_face_embedding(face_image_path):
    try:
        embedding = DeepFace.represent(face_image_path, model_name="Facenet")[0]['embedding']
        return embedding
    except Exception as e:
        print(f"Error processing {face_image_path}: {e}")
        return None

def find_and_remove_duplicates_in_video_folder(video_folder_path, threshold=0.6):
    embeddings = []
    faces = []

    for face_image in os.listdir(video_folder_path):
        face_image_path = os.path.join(video_folder_path, face_image)

        if face_image_path.endswith(".jpg"):
            embedding = get_face_embedding(face_image_path)
            if embedding is not None:
                embeddings.append((face_image_path, embedding))

    unique_faces = []
    unique_embeddings = []

    for face_image_path, embedding in embeddings:
        is_duplicate = False

        for unique_embedding in unique_embeddings:
            similarity = cosine_similarity([embedding], [unique_embedding])[0][0]
            if similarity > threshold:
                is_duplicate = True
                break

        if not is_duplicate:
            unique_faces.append(face_image_path)
            unique_embeddings.append(embedding)

    for face_image_path in embeddings:
        if face_image_path[0] not in unique_faces:
            os.remove(face_image_path[0])

    print(f"Unique faces in {video_folder_path}: {len(unique_faces)}")

faces_dir = "faces"

for video_folder in os.listdir(faces_dir):
    video_folder_path = os.path.join(faces_dir, video_folder)

    if os.path.isdir(video_folder_path):
        print(f"Processing folder: {video_folder}")
        find_and_remove_duplicates_in_video_folder(video_folder_path, threshold=0.6)



# import os
# import shutil

# # Path to the faces folder
# faces_folder = "yolov5_face"

# # Remove the folder and all its contents
# if os.path.exists(faces_folder):
#     shutil.rmtree(faces_folder)
#     print(f"Cleared the '{faces_folder}' folder.")
# else:
#     print(f"The '{faces_folder}' folder does not exist.")

# # Recreate an empty faces folder
# os.makedirs(faces_folder, exist_ok=True)
# print(f"Recreated an empty '{faces_folder}' folder.")